#!/usr/bin/env python3
# mdnf -- my dnf frontend with changes to 'search' command
# Author: Noah Friedman <friedman@splode.com>
# Created: 2016-08-03
# Public domain

# $Id: mdnf,v 1.1 2016/08/04 06:14:50 friedman Exp $

# Commentary:

# I find it hard to read the output from 'dnf search' when results are not
# in alphabetical order.  Its algorithm for prioritizing results isn't
# transparent enough to make sense to me, especially when there are dozens
# of results.  The lack of column alignment also makes it difficult to scan.

# Major differences in this version:
#	* Results are in alphabetical order
#	* Version number, architecture, and repository are included.
#	* Columns are aligned
#	* Searching on architecture provided
# 	* If multiple search terms provided then select the conjunction,
# 	  rather than the disjunction, of the results.  That is, results
# 	  must match all terms, not just any of them.
#       * Output is not folded (doing so breaks pipelines)

# Code:

# Needed in case we have to exec this using python 2.7 on fedora 22
from __future__ import print_function

import sys
import fcntl
import termios
import struct

def _my_term_width( fd=1 ):
    try:
        buf = 'abcdefgh'
        buf = fcntl.ioctl( fd, termios.TIOCGWINSZ, buf )
        ret = struct.unpack( b'hhhh', buf )[1]
        if ret == 0: return 256
        if ret < 20: return  20
        return ret
    except IOError:
        return 256

# We don't use this for the search command anymore, but
# monkeypatch it for any other commands that might try to use it.
from dnf.cli import term
term._term_width = _my_term_width


import dnf.match_counter

column_brevity = False

def _my_search( self, args ):
    counter = dnf.match_counter.MatchCounter()

    search_cols = [ 'name', 'summary' ]
    if self.opts.all:
        search_cols.extend( ('description', 'url') )

    for arg in args:
        for col in search_cols:
            self._search_counted( counter, col, arg )

    if not self.opts.all:
        needles = len( args )
        for pkg in tuple( counter.keys() ):
            if len( counter.matched_needles( pkg )) != needles:
                del counter[ pkg ]

    results = counter
    if not self.base.conf.showdupesfromrepos:
        results = self.base.sack.query().filterm( pkg=counter.keys() ).latest()

    allargs = set( args )
    seen    = set()
    row     = []
    for pkg in sorted( results, key=lambda k: str( k ).lower() ):
        if column_brevity:
            if pkg.name in seen:
                continue
            seen.add( pkg.name )
        elif not self.base.conf.showdupesfromrepos and not self.opts.all:
            if pkg.name + pkg.arch in seen:
                continue
            seen.add( pkg.name + pkg.arch )

        if counter.matched_needles( pkg ) != allargs:
            continue

        if column_brevity:
            row.append( (pkg.name, pkg.summary) )
        else:
            row.append( (pkg.name,
                         pkg.version + '-' + pkg.release,
                         pkg.arch,
                         pkg.reponame,
                         pkg.summary) )

    if len( row ) == 0:
        raise dnf.exceptions.Error( 'No matches found.' )

    width = [ max( len( r[i] ) for r in row )
              for i in range( len( row[0] ))
            ]
    width[-1] = ''  # don't pad out last column
    fmt = '  '.join ( '{{:<{}}}'.format( w ) for w in width )
    for r in row:
        print( fmt.format( *r ))

# monkeypatch
from dnf.cli.commands import search
search.SearchCommand._search = _my_search


if __name__ == '__main__':
    try:
        from dnf.cli import main

        showdupes = True
        for _ in range( 2 ):
            if sys.argv[1] in ('-b', '--brief', '--brevity'):
                column_brevity = True
                sys.argv.pop( 1 )
            elif sys.argv[1] in ('-u', '--unique'):
                showdupes = False
                sys.argv.pop( 1 )

        if sys.argv[1] in ( 'search', 'se' ):
            myargs = ['--quiet', '--cacheonly']
            if showdupes:
                myargs.append( '--showduplicates' )
            for arg in myargs:
                sys.argv.insert( 1, arg )

        main.user_main( sys.argv[1:], exit_code=True )

    except KeyboardInterrupt:
        pass

# eof
